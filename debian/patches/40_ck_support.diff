--- a/sesman/session.c
+++ b/sesman/session.c
@@ -30,6 +30,9 @@
 #include <errno.h>
 //#include <time.h>
 
+#include <ConsoleKit/ck-connector/ck-connector.h>
+#include <pwd.h>
+
 extern tbus g_sync_event;
 extern unsigned char g_fixedkey[8];
 extern struct config_sesman *g_cfg; /* in sesman.c */
@@ -227,7 +230,7 @@
 
 /******************************************************************************/
 static void DEFAULT_CC
-session_start_sessvc(int xpid, int wmpid, long data, char *username, int display)
+session_start_sessvc(int xpid, int wmpid, long data, char *username, int display, environment_item environment[], int envsize)
 {
     struct list *sessvc_params = (struct list *)NULL;
     char wmpid_str[25];
@@ -258,7 +261,11 @@
     list_add_item(sessvc_params, (long)g_strdup(wmpid_str));
     list_add_item(sessvc_params, 0); /* mandatory */
 
-    env_set_user(username, 0, display);
+    log_message(LOG_LEVEL_DEBUG, "Changing process to user %s", username);
+
+    env_set_user(username, 0, display, environment, envsize);
+
+    log_message(LOG_LEVEL_DEBUG, "Starting %s", exe_path);
 
     /* executing sessvc */
     g_execvp(exe_path, ((char **)sessvc_params->items));
@@ -375,6 +382,90 @@
     return 0;
 }
 
+static int APP_CC
+uid_from_username(char *username)
+{
+    struct passwd * pwd = getpwnam(username);
+    if (pwd != NULL)
+    {
+        return pwd->pw_uid;
+    }
+    return -1;
+}
+
+static int APP_CC
+ck_start_session(CkConnector *ck, char *username, int display, char *client_ip)
+{
+    DBusError error;
+    const char *session;
+    char display_device[20];
+    char x11_display[10];
+    char x11_display_device[20];
+    const char *remote_host_name;
+    uid_t       uid;
+    dbus_bool_t is_local;
+
+    //g_snprintf(display_device, 20, "/dev/tty%d", display);
+    g_snprintf(display_device, 20, "/dev/x%d", display);
+    g_snprintf(x11_display, 10, ":%d", display);
+    g_snprintf(x11_display_device, 20, "");
+    //g_snprintf(x11_display_device, 20, "/dev/tty%d", display);
+    remote_host_name = client_ip;
+    uid = uid_from_username(username);
+    is_local = FALSE;
+
+    log_message(LOG_LEVEL_ALWAYS, "Starting consolekit connection for user %s(%d), display %d (%s) and client %s.",
+            username, uid, display, display_device, client_ip);
+
+    dbus_error_init (&error);
+//    if (ck_connector_open_session_with_parameters (ck,
+//                                                         &error,
+//                                                         "unix-user", &uid,
+//                                                         "display-device", &display_device,
+//                                                         "x11-display", &x11_display,
+//                                                         "x11-display-device", &x11_display_device,
+//                                                         "remote-host-name", &remote_host_name,
+//                                                         "is-local", &is_local,
+//                                                         NULL))
+//    {
+    if (ck_connector_open_session(ck, &error))
+    {
+        session = ck_connector_get_cookie(ck);
+        g_setenv("XDG_SESSION_COOKIE", session, 1);
+        log_message(LOG_LEVEL_INFO, "Created new consolekit session with cookie %s.", session);
+    }
+    else
+    {
+        if (dbus_error_is_set (&error)) {
+            log_message(LOG_LEVEL_ERROR, "Error opening consolekit session - %s.", error.message);
+            dbus_error_free (&error);
+        } else {
+            log_message(LOG_LEVEL_ERROR, "insufficient privileges or D-Bus / ConsoleKit not available");
+        }
+    }
+}
+
+static int APP_CC
+ck_stop_session(CkConnector *ck)
+{
+    DBusError error;
+    dbus_error_init (&error);
+    log_message(LOG_LEVEL_ALWAYS, "Closing consolekit connection with connection %p.", ck);
+    if (ck != NULL)
+    {
+        if (!ck_connector_close_session(ck, &error))
+        {
+            if (dbus_error_is_set(&error)) {
+                log_message(LOG_LEVEL_ALWAYS, "Error closing consolekit connection (%s).", error.message);
+                dbus_error_free(&error);
+            } else {
+                log_message(LOG_LEVEL_ALWAYS, "Error closing consolekit connection.");
+            }
+        }
+        ck_connector_unref(ck);
+    }
+}
+
 /******************************************************************************/
 /* called with the main thread */
 static int APP_CC
@@ -398,6 +489,8 @@
     time_t ltime;
     struct tm stime;
     char execvpparams[2048];
+    CkConnector *ck;
+    environment_item environment[2];
 
     /* initialize (zero out) local variables: */
     g_memset(&ltime, 0, sizeof(time_t));
@@ -444,10 +537,21 @@
         return 0;
     }
 
+    ck = NULL;
+//    ck = ck_connector_new();
+//    if (ck == 0)
+//    {
+//        log_message(LOG_LEVEL_ERROR, "cannot create consolekit connection "
+//                    "element - user %s", username);
+//        return 0;
+//    }
+
     pid = g_fork();
 
     if (pid == -1)
     {
+        ck_connector_unref(ck);
+        ck = NULL;
         log_message(LOG_LEVEL_ERROR, "cannot fork process for wm and x"
                     " - user %s, display=%d, sessioncount=%d", username, display, g_session_count);
     }
@@ -468,9 +572,13 @@
         }
         else if (xpid == 0) /* child (child sesman) xserver */
         {
-            env_set_user(username, passwd_file, display);
+            log_message(LOG_LEVEL_DEBUG, "Forked the process for running xserver for user %s", username);
+
+            env_set_user(username, passwd_file, display, NULL, 0);
             env_check_password_file(passwd_file, password);
 
+            log_message(LOG_LEVEL_DEBUG, "Running xserver process as user %s", username);
+
             if (type == SESMAN_SESSION_TYPE_XVNC)
             {
                 xserver_params = list_create();
@@ -487,7 +595,7 @@
 
                 /* additional parameters from sesman.ini file */
                 //config_read_xserver_params(SESMAN_SESSION_TYPE_XVNC,
-                //                           xserver_params);
+                //                           xserver_params);c
                 list_append_list_strdup(g_cfg->vnc_params, xserver_params, 0);
 
                 /* make sure it ends with a zero */
@@ -547,22 +655,32 @@
         }
         else /* parent (child sesman) */
         {
-            wmpid = g_fork();
-
-            if (wmpid == -1)
+            wait_for_xserver(display);
+            if (x_server_running(display))
             {
-                log_message(LOG_LEVEL_ERROR, "cannot fork process for wm"
-                    " - user %s, display=%d, sessioncount=%d", username, display, g_session_count);
-            }
-            else if (wmpid == 0) /* child */
-            {
-                wait_for_xserver(display);
-                env_set_user(username, 0, display);
+//                ck_start_session(ck, username, display, client_ip);
+
+                environment[0].key = "XDG_SESSION_COOKIE";
+                environment[0].value = g_getenv("XDG_SESSION_COOKIE");
+                environment[1].key = "GDMSESSION";
+                environment[1].value = "FAKE_SESSION";
+
+                wmpid = g_fork();
 
-                if (x_server_running(display))
+                if (wmpid == -1)
                 {
+                    log_message(LOG_LEVEL_ERROR, "cannot fork process for wm"
+                        " - user %s, display=%d, sessioncount=%d", username, display, g_session_count);
+                }
+                else if (wmpid == 0) /* child */
+                {
+                    log_message(LOG_LEVEL_DEBUG, "Forked the process for running windowmanager for pid %s", username);
+
+                    env_set_user(username, 0, display, environment, 2);
                     auth_set_env(data);
 
+                    log_message(LOG_LEVEL_DEBUG, "Running windowmanager process as user %s", username);
+
                     if (directory != 0)
                     {
                         if (directory[0] != 0)
@@ -575,6 +693,8 @@
                     {
                         if (program[0] != 0)
                         {
+                            log_message(LOG_LEVEL_DEBUG, "Starting program %s for user %s", program, username);
+
                             g_execlp3(program, program, 0);
                             log_message(LOG_LEVEL_ALWAYS,
                                         "error starting program %s for user %s - pid %d",
@@ -589,6 +709,7 @@
 
                         if (g_file_exist(text))
                         {
+                            log_message(LOG_LEVEL_DEBUG, "Starting user windowmanager %s for user %s", text, username);
                             g_execlp3(text, g_cfg->user_wm, 0);
                             log_message(LOG_LEVEL_ALWAYS, "error starting user "
                                         "wm for user %s - pid %d", username, g_getpid());
@@ -607,6 +728,8 @@
                     /* if we're here something happened to g_execlp3
                        so we try running the default window manager */
                     g_sprintf(text, "%s/%s", XRDP_CFG_PATH, g_cfg->default_wm);
+
+                    log_message(LOG_LEVEL_DEBUG, "Starting default windowmanager %s for user %s", text, username);
                     g_execlp3(text, g_cfg->default_wm, 0);
 
                     log_message( LOG_LEVEL_ALWAYS, "error starting default "
@@ -621,6 +744,7 @@
                                 g_cfg->default_wm);
 
                     /* still a problem starting window manager just start xterm */
+                    log_message(LOG_LEVEL_DEBUG, "Starting xterm");
                     g_execlp3("xterm", "xterm", 0);
 
                     /* should not get here */
@@ -630,61 +754,63 @@
                     log_message(LOG_LEVEL_DEBUG, "errno: %d, description: "
                                 "%s", errno, g_get_strerror());
                 }
-                else
+                else /* parent (child sesman)*/
                 {
-                    log_message(LOG_LEVEL_ERROR, "another Xserver might "
-                                "already be active on display %d - see log", display);
+                    g_snprintf(text, 256, "%d", display);
+                    g_setenv("XRDP_SESSVC_DISPLAY", text, 1);
+                    g_snprintf(text, 256, ":%d.0", display);
+                    g_setenv("DISPLAY", text, 1);
+                    /* new style waiting for clients */
+                    session_start_sessvc(xpid, wmpid, data, username, display, environment, 2);
                 }
 
                 log_message(LOG_LEVEL_DEBUG, "aborting connection...");
                 g_exit(0);
             }
-            else /* parent (child sesman)*/
+            else
             {
-				wait_for_xserver(display);
-                if (x_server_running(display))
-                {
-					g_snprintf(text, 255, "%d", display);
-					g_setenv("XRDP_SESSVC_DISPLAY", text, 1);
-					g_snprintf(text, 255, ":%d.0", display);
-					g_setenv("DISPLAY", text, 1);
-					/* new style waiting for clients */
-					session_start_sessvc(xpid, wmpid, data, username, display);
-                }
+                 log_message(LOG_LEVEL_ERROR, "another Xserver might "
+                             "already be active on display %d - see log", display);
             }
         }
     }
     else /* parent sesman process */
     {
-		wait_for_xserver(display);
-        if (x_server_running(display))
-        {
-			temp->item->pid = pid;
-			temp->item->display = display;
-			temp->item->width = width;
-			temp->item->height = height;
-			temp->item->bpp = bpp;
-			temp->item->data = data;
-			g_strncpy(temp->item->client_ip, client_ip, 255);   /* store client ip data */
-			g_strncpy(temp->item->name, username, 255);
-
-			ltime = g_time1();
-			localtime_r(&ltime, &stime);
-			temp->item->connect_time.year = (tui16)(stime.tm_year + 1900);
-			temp->item->connect_time.month = (tui8)stime.tm_mon;
-			temp->item->connect_time.day = (tui8)stime.tm_mday;
-			temp->item->connect_time.hour = (tui8)stime.tm_hour;
-			temp->item->connect_time.minute = (tui8)stime.tm_min;
-			zero_time(&(temp->item->disconnect_time));
-			zero_time(&(temp->item->idle_time));
-
-			temp->item->type = type;
-			temp->item->status = SESMAN_SESSION_STATUS_ACTIVE;
-
-			temp->next = g_sessions;
-			g_sessions = temp;
-			g_session_count++;
-        }
+        temp->item->pid = pid;
+        temp->item->display = display;
+        temp->item->width = width;
+        temp->item->height = height;
+        temp->item->bpp = bpp;
+        temp->item->data = data;
+        g_strncpy(temp->item->client_ip, client_ip, 255);   /* store client ip data */
+        g_strncpy(temp->item->name, username, 255);
+
+        ltime = g_time1();
+        localtime_r(&ltime, &stime);
+        temp->item->connect_time.year = (tui16)(stime.tm_year + 1900);
+        temp->item->connect_time.month = (tui8)stime.tm_mon;
+        temp->item->connect_time.day = (tui8)stime.tm_mday;
+        temp->item->connect_time.hour = (tui8)stime.tm_hour;
+        temp->item->connect_time.minute = (tui8)stime.tm_min;
+        zero_time(&(temp->item->disconnect_time));
+        zero_time(&(temp->item->idle_time));
+
+        temp->item->type = type;
+        temp->item->status = SESMAN_SESSION_STATUS_ACTIVE;
+
+        temp->item->ck = ck;
+
+        log_message(LOG_LEVEL_DEBUG, "Going to register pid %d and display %d for user %s", pid, display, username);
+        /*THREAD-FIX require chain lock */
+        lock_chain_acquire();
+
+        temp->next = g_sessions;
+        g_sessions = temp;
+        g_session_count++;
+
+        /*THREAD-FIX release chain lock */
+        lock_chain_release();
+        log_message(LOG_LEVEL_DEBUG, "Registered pid %d and display %d for user %s", pid, display, username);
     }
 
     return display;
@@ -707,14 +833,17 @@
     }
     else if (pid == 0)
     {
-        env_set_user(username, 0, display);
+        env_set_user(username, 0, display, NULL, 0);
         g_snprintf(text, 255, "%s/%s", XRDP_CFG_PATH, "reconnectwm.sh");
 
         if (g_file_exist(text))
         {
+            log_message(LOG_LEVEL_DEBUG, "Reconnect to windowmanager process %s as user %s", text, username);
+
             g_execlp3(text, g_cfg->default_wm, 0);
         }
 
+        log_message(LOG_LEVEL_DEBUG, "Reconnection to %s failed.", text);
         g_exit(0);
     }
 
@@ -839,6 +968,8 @@
 
         if (tmp->item->pid == pid)
         {
+            ck_stop_session(tmp->item->ck);
+
             /* deleting the session */
             log_message(LOG_LEVEL_INFO, "++ terminated session:  username %s, display :%d.0, session_pid %d, ip %s", tmp->item->name, tmp->item->display, tmp->item->pid, tmp->item->client_ip);
             g_free(tmp->item);
--- a/sesman/Makefile.am
+++ b/sesman/Makefile.am
@@ -6,9 +6,11 @@
   -DXRDP_SHARE_PATH=\"${datadir}/xrdp\" \
   -DXRDP_PID_PATH=\"${localstatedir}/run\"
 
+DBUS1=$(shell ${PKG_CONFIG} --cflags dbus-1)
 INCLUDES = \
   -I$(top_srcdir)/common \
-  -I$(top_srcdir)/sesman/libscp
+  -I$(top_srcdir)/sesman/libscp \
+  ${DBUS1}
 
 if SESMAN_NOPAM
 AUTH_C = verify_user.c
@@ -50,7 +52,9 @@
   $(top_builddir)/common/libcommon.la \
   $(top_builddir)/sesman/libscp/libscp.la \
   $(AUTH_LIB) \
-  -lpthread
+  -lpthread \
+  -lck-connector \
+  -ldbus-1
 
 sesmansysconfdir=$(sysconfdir)/xrdp
 
--- a/sesman/tools/Makefile.am
+++ b/sesman/tools/Makefile.am
@@ -6,10 +6,12 @@
   -DXRDP_SHARE_PATH=\"${datadir}/xrdp\" \
   -DXRDP_PID_PATH=\"${localstatedir}/run\"
 
+DBUS1=$(shell ${PKG_CONFIG} --cflags dbus-1)
 INCLUDES = \
   -I$(top_srcdir)/common \
   -I$(top_srcdir)/sesman/libscp \
-  -I$(top_srcdir)/sesman
+  -I$(top_srcdir)/sesman \
+  ${DBUS1}
 
 bin_PROGRAMS = \
   xrdp-sesrun \
--- a/sesman/session.h
+++ b/sesman/session.h
@@ -30,6 +30,8 @@
 
 #include "libscp_types.h"
 
+#include <ConsoleKit/ck-connector/ck-connector.h>
+
 #define SESMAN_SESSION_TYPE_XRDP  1
 #define SESMAN_SESSION_TYPE_XVNC  2
 
@@ -75,6 +77,7 @@
   struct session_date disconnect_time;
   struct session_date idle_time;
   char client_ip[256];
+  CkConnector *ck;
 };
 
 struct session_chain
--- a/sesman/env.c
+++ b/sesman/env.c
@@ -60,7 +60,7 @@
 
 /******************************************************************************/
 int DEFAULT_CC
-env_set_user(char *username, char *passwd_file, int display)
+env_set_user(char *username, char *passwd_file, int display, environment_item environ[], int envsize)
 {
     int error;
     int pw_uid;
@@ -70,6 +70,7 @@
     char pw_dir[256];
     char pw_gecos[256];
     char text[256];
+    int i;
 
     error = g_getuser_info(username, &pw_gid, &pw_uid, pw_shell, pw_dir,
                            pw_gecos);
@@ -107,6 +108,11 @@
             g_setenv("LANG", "en_US.UTF-8", 1);
             g_setenv("XRDP_SESSION", "1", 1);
 
+            for (i = 0; i < envsize; i++)
+            {
+                g_setenv(environ[i].key, environ[i].value, 1);
+            }
+
             if (passwd_file != 0)
             {
                 if (0 == g_cfg->auth_file_path)
--- a/sesman/env.h
+++ b/sesman/env.h
@@ -27,6 +27,14 @@
 #ifndef ENV_H
 #define ENV_H
 
+struct environment_item
+{
+    char * key;
+    char * value;
+};
+
+typedef struct environment_item environment_item;
+
 /**
  *
  * @brief Creates vnc password file
@@ -44,10 +52,12 @@
  * @param username Username
  * @param passwd_file VNC password file
  * @param display The session display
+ * @param environ Additional environment variables.
+ * @param envsize Number of environment variables passed.
  * @return 0 on success, g_getuser_info() error codes on error
  *
  */
 int DEFAULT_CC
-env_set_user(char* username, char* passwd_file, int display);
+env_set_user(char* username, char* passwd_file, int display, environment_item environ[], int envsize);
 
 #endif
--- a/instfiles/pam.d/xrdp-sesman
+++ b/instfiles/pam.d/xrdp-sesman
@@ -1,5 +1,6 @@
 #%PAM-1.0
 @include common-auth
 @include common-account
+session	optional			pam_ck_connector.so
 @include common-session
 @include common-password
